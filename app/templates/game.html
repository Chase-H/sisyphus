{% extends "base.html" %}
{% block content %}
<script src="{{ url_for('static', filename='js/main_scripts.js') }}"></script>
<button id="rules" onclick="showRules(this)">Hide Rules
</button>
<div style="display:flex" id="rules_parent">
  <div id="rules_text" style="display:block">
  <p>
  How to Lose: <br>
  Use the arrow keys. <br>
  Try to move backwards. You can't.<br>
  Try to move downwards. You cant.<br>
  Like Sisyphus, you only have one path: <br>
  up and to the right, <br>
  to the top of the mountain, <br>
  to freedom. <br>
  Victory is an illusion. <br>
  Good luck.<br>
  </p>
  </div >

  <div>
    <textarea id="progress"></textarea>
    <canvas id="gameCanvas" width="300px" height= "300px" style="border:1px solid">
    </canvas>
  </div>
</div>

<script>
  // to do
  //better graphics/sprites
  // add in error handling for movement outside of screen
  // https://www.sitepoint.com/delay-sleep-pause-wait/
  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  const board = document.getElementById("gameCanvas");
  const board_ctx = board.getContext("2d");
  const progress = document.getElementById("progress");
  const maxHeight = document.body.scrollHeight;
  const maxWidth = document.body.scrollWidth;

  const direction = Object.freeze({
    "UP": 1,
    "DOWN": 2,
    "LEFT": 3,
    "RIGHT": 4
  });

  var Sisyphus = {
    "x": 0,
    "y": 270
  };

  var Boulder = {
    "x" : Sisyphus["x"]+30,
    "y" : Sisyphus["y"] - 90
  };

  var lastKeyPressed = "";
  var distanceWalked = 0;
  var mountainsClimbed = 0;
  var anotherKeyPressed = false;

  function showRules(element) {
  var ruleText = document.getElementById(element.id + "_text");
      if (ruleText.style.display == "none") {
          ruleText.style.display = "block";
          element.innerHTML = "Hide Rules";
          }
      else if (ruleText.style.display == "block") {
          ruleText.style.display = "none";
          element.innerHTML = "Show Rules";
          }
  }

  document.addEventListener('keydown', function(event) {
    anotherKeyPressed = true;
    //LEFT KEY
    if(event.keyCode == 37) {
      window.alert("Your Only Option Are Up and Forward. In That Order.");
    }
    //RIGHT KEY
    else if(event.keyCode == 39 && lastKeyPressed == 38)  {
      moveSisyphusAndBoulder(direction.RIGHT, 10);
      lastKeyPressed = 39;
      distanceWalked += 10;
      progress.value = "Distance Traveled: " + distanceWalked + "m. Mountains Climbed: " + mountainsClimbed;
    }
    //DOWN KEY
    else if(event.keyCode == 40) {
      window.alert("Your Only Option Are Up and Forward. In That Order.");
    }
    //UP KEY
    else if(event.keyCode == 38 && (lastKeyPressed == "" || lastKeyPressed == 39)) {
      upPressed = true;
      moveSisyphusAndBoulder(direction.UP, 10);
      lastKeyPressed = 38;
      distanceWalked += 10;
      progress.value = "Distance Traveled: " + distanceWalked + "m. Mountains Climbed: " + mountainsClimbed;
    } else {
    }
  });



  function showSisyphus() {
    board_ctx.clearRect(0, 0, maxWidth, maxHeight);
    board_ctx.fillStyle = "gray";
    board_ctx.strokestyle = 'black';
    board_ctx.fillRect(Sisyphus["x"], Sisyphus["y"], 30, 30);
    board_ctx.strokeRect(Sisyphus["x"], Sisyphus["y"], 30, 30);
    board_ctx.fillRect(Boulder["x"], Boulder["y"], 80, 120);
    board_ctx.strokeRect(Boulder["x"], Boulder["y"], 80, 120);

  }

  function moveSisyphusAndBoulder(direction, amount) {
    // 1 = up, 2 = down, 3 = left, 4= right

    if (Sisyphus["x"] == 270 && Sisyphus["y"] == 0) {
      Sisyphus["x"] = 0
      Sisyphus["y"] = 270
      Boulder["x"] = 30
      Boulder["y"] = 180
      //showSisyphus();
      mountainsClimbed++;
      return;
    }

    switch (direction) {
      case 1:
        if ((Sisyphus["y"] + amount) < 0 ) {
          console.log("Sisyphus is too close to the top of the screen.");
        } else {

          Sisyphus["y"] -= amount;
          Boulder["y"] -= amount;
         // showSisyphus();
         // animate();
        };
        break;
      case 2:

        if ((Sisyphus["y"] + amount) > maxHeight) {
          console.log("Sisyphus is too close to the bottom of the screen.");
        } else {
          Sisyphus["y"] += amount;
          Boulder["y"] += amount;
          //showSisyphus();
        //  animate();
        };
        break;
      case 3:

        if ((Sisyphus["x"] - amount) < 0) {
          console.log("Sisyphus is too close to the left of the screen.");
        } else {
          Sisyphus["x"] -= amount;
          Boulder["x"] -= amount;
         // showSisyphus();
         // animate();
        };
        break;
      case 4:

        if ((Sisyphus["x"] + amount) < 0) {
          console.log("Sisyphus is too close to the right of the screen.");
        } else {
          Sisyphus["x"] += amount;
          Boulder["x"] += amount;
          //showSisyphus();
         // animate();
        }
        break;
    }

  }


const timeout = ms => new Promise(resolve => setTimeout(resolve, ms));

//once a key has been pressed, recursively waits 1 second, checks if new key has been pressed and if not 
//moves user down and left one movement
//to do:
//stop sisyphus if at edge of screen
//decrement mountains
async function checkMovement(keyPress) {
  anotherKeyPressed = false;
  await timeout(1000);
  //value before any keypress
  if (keyPress != "") {
    if (keyPress == lastKeyPressed && !anotherKeyPressed) {
      //console.log(keyPress, lastKeyPressed, " no key pressed");
      moveSisyphusAndBoulder(direction.DOWN, 10);
      moveSisyphusAndBoulder(direction.LEFT, 10);
      distanceWalked -= 20;
      progress.value = "Distance Traveled: " + distanceWalked + "m. Mountains Climbed: " + mountainsClimbed;
      return await checkMovement(lastKeyPressed);
    } 
    else {
      //console.log(lastKeyPressed, " key pressed within 1 second");
    } 
}
  return await checkMovement(lastKeyPressed);
}

checkMovement(lastKeyPressed);



  async function loopOverTestInput(input) {
    for(var i = 0; i < input.length; i ++) {
      moveSisyphusAndBoulder(input[i]["direction"], input[i]["amount"]);
      await sleep(1000);
    }
  }

  //test input
  let input = [{"direction":direction.UP, "amount":10},
               {"direction":direction.UP, "amount":10},
               {"direction":direction.RIGHT, "amount":10},
               {"direction":direction.DOWN, "amount":10},
               {"direction":direction.RIGHT, "amount":10},
               {"direction":direction.UP, "amount":10},
               {"direction":direction.UP, "amount":10}];


               











  //////////////////////////////////////////////////
  /////////////////////////////////////////////////
  //////////////////////////////////////////////////
  //animate sprites

  // A cross-browser requestAnimationFrame
// See https://hacks.mozilla.org/2011/08/animating-with-javascript-from-setinterval-to-requestanimationframe/
var requestAnimFrame = (function(){
    return window.requestAnimationFrame       ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame    ||
        window.oRequestAnimationFrame      ||
        window.msRequestAnimationFrame     ||
        function(callback){
            window.setTimeout(callback, 1000 / 60);
        };
})();



  //const initialBoulderWidth = 50;
  //const initialBoulderHeight = 50;
  //boulder and player sprite counts
  let boulderMoveSprites = [...Array(73).keys()];
  let playerMoveSprites = [...Array(12).keys()]
  //let frameCount = 0;
  //let spriteIndex = 0;
  playerLoaded = false;
  boulderLoaded = false;

  /////////////////////////////
//////////////////////////////sprite code
(function() {
    function Sprite(image, pos, size, speed, frames, dir, once) {
        this.pos = pos;
        this.size = size;
        this.speed = typeof speed === 'number' ? speed : 0;
        this.frames = frames;
        this._index = 0;
        this.image = image;
        this.dir = dir || 'horizontal';
        this.once = once;
    };

    Sprite.prototype = {
        update: function() {
            this._index += 1;
        },

        render: function(board_ctx) {
            var frame;
            var max = this.frames.length;
            //restart if get to end of sprite file
            if (this._index == max) {
                frame = this.frames[0];
                this._index = 0;
            }
            frame = this.frames[this._index];

            if(this.once) {
                this.done = true;
                return;
            }


            var x = this.pos[0];
            var y = this.pos[1];

            console.log(typeof this.image);
            board_ctx.drawImage(this.image,
                          x, y,
                          this.size[0], this.size[1],
                          0, 0,
                          this.size[0], this.size[1]);
        }
    };

    window.Sprite = Sprite;
})();

///////////////////////////////////
  //loading images
  //var boulderImage = document.createElement("boulderImage");
  //drawImage args: image location, starting x and y coordinates from image, 
  //ending x and y coordinates from image, starting x and y coordinates from canvas, ending x and y coordinates from canvas
  /*
  let boulderImage = new Image();
  boulderImage.src = "{{ url_for('static', filename='boulderSprite.png')}}";
  boulderImage.onload = function() {
    console.log("boulder loaded");
    boulderLoaded = true;
    board_ctx.drawImage(boulderImage, 0, 0, 50, 50,50,50,100,100)

  }; */

  //let playerImage = document.createElement("playerImage");
  let playerImage = new Image();
  playerImage.src = "{{ url_for('static', filename='playerSprite2.png')}}";
  playerImage.onload = function() {
    console.log("player loaded");





    var width = 337;
    var height = 276;
    var scale = .1;
    var gameWidth = width * scale;
    var gameHeight = height * scale;
    playerLoaded = true;

  function drawFrame(frameX, frameY, canvasX, canvasY) {
    board_ctx.drawImage(playerImage,
                frameX * width, frameY * height, width, height,
                canvasX, canvasY, gameWidth, gameHeight);
  }

  drawFrame(0, 0, 0, 0);
  drawFrame(1, 0, gameWidth, 0);
  drawFrame(2, 0, gameWidth * 2, 0);
  drawFrame(3, 0, gameWidth * 3, 0);

/*
    board_ctx.drawImage(playerImage, 0, 0, width,height,
    0,0,gameWidth,height * scale);
    board_ctx.drawImage(playerImage, width, 0, width,height,
    gameWidth,0,gameWidth,gameHeight);
    board_ctx.drawImage(playerImage, width * 2, 0, width,height,
    gameWidth * 2,0,gameWidth,gameHeight);
*/
  };

  let background = new Image();
  background.src = "{{ url_for('static', filename='background.png')}}";
  background.onload = function() {
   // board_ctx.drawImage(background, 0, 0);

  };
/* 
  //setting player and boulder location + sprite info
  //https://archive.jlongster.com/Making-Sprite-based-Games-with-Canvas
  var player = {
    pos: [Sisyphus["x"], Sisyphus["y"]],
    sprite: new Sprite(image = playerImage, pos = [0, 0], size = [50, 50], speed=16, frames = playerMoveSprites)
};

var boulder = {
    pos: [Boulder["x"],Boulder["y"]],
    sprite: new Sprite(image = boulderImage, pos = [0, 0], size = [50, 50], speed=16, frames = boulderMoveSprites)
};



/////////////////
////rendering and updating sprites
  function main() {
    update()
    render();
    requestAnimFrame(main);
};


function init() {
    main();
}

function update() {
    updateEntities();
};

function updateEntities() {
    // Update the player sprite animation on keypress
    player.sprite.update();
}
    // Draw everything
    function render() {
      if (playerLoaded) {
        console.log("rendering player");
        renderEntity(player);
      }
      if (boulderLoaded) {
        console.log("rendering boulder");
        renderEntity(boulder);
      }
    };
    
    function renderEntities(list) {
        for(var i=0; i<list.length; i++) {
            renderEntity(list[i]);
        }    
    }
    
    function renderEntity(entity) {
        board_ctx.save();
        //console.log("rendering entity");
        //board_ctx.drawImage(entity.image, entity.pos[0], entity.pos[1]);
        board_ctx.translate(entity.pos[0], entity.pos[1]);
        entity.sprite.render(board_ctx);
        board_ctx.restore();
    }


  




  main();



 */





</script>
{% endblock %}